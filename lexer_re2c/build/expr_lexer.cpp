/* Generated by re2c 2.0.1 on Sun Aug 23 19:01:59 2020 */
#line 1 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <istream>
#include "lexer.h"

#define YYMAXFILL 2


int ExprLexer::getNextToken(semantic_type *yylval)
{

    #define YYFILL(n) do {\
        FillStatus st = input.fill(n);\
        switch(st){\
            case FillStatus::Eof : return TkEof();\
            case FillStatus::Error : return TkError();\
            default:\
                break;\
        }\
    }while(0)

    
    if(remaining_tokens.size() > 0){
        remaining_tokens.pop_back();
        return makeToken(token::Dedent);
    }

    while(true){
    
    loop:
        input.tok = input.cur;

        
#line 39 "expr_lexer.cpp"
{
	char yych;
	if ((input.lim - input.cur) < 2) YYFILL(2);
	yych = *input.cur;
	switch (yych) {
	case 0x00:	goto yy2;
	case '\t':
	case ' ':	goto yy6;
	case '\n':	goto yy9;
	case '!':	goto yy11;
	case '"':	goto yy12;
	case '#':	goto yy13;
	case '%':	goto yy16;
	case '(':	goto yy18;
	case ')':	goto yy20;
	case '*':	goto yy22;
	case '+':	goto yy24;
	case ',':	goto yy26;
	case '-':	goto yy28;
	case '/':	goto yy30;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy32;
	case '<':	goto yy35;
	case '=':	goto yy37;
	case '>':	goto yy39;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy41;
	default:	goto yy4;
	}
yy2:
	++input.cur;
#line 59 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{return input.eof? TkEof(): TkError();}
#line 132 "expr_lexer.cpp"
yy4:
	++input.cur;
yy5:
#line 50 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{return TkError();}
#line 138 "expr_lexer.cpp"
yy6:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy6;
	default:	goto yy8;
	}
yy8:
#line 60 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{continue;}
#line 151 "expr_lexer.cpp"
yy9:
	++input.cur;
#line 51 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{   
                        //continue;
                        std::cout<<"global newline: "<<input.tokenText();
                        std::cout<<"global newline size: "<<input.tokenText().length() <<"\n";
                        //makeToken(token::TK_EOF);
                        input.tok = input.cur;
                        goto indent_block;
                    }
#line 163 "expr_lexer.cpp"
yy11:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy44;
	default:	goto yy5;
	}
yy12:
	yych = *(input.mark = ++input.cur);
	switch (yych) {
	case '\n':
	case '(':
	case ')':
	case '|':	goto yy5;
	default:	goto yy47;
	}
yy13:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\n':	goto yy15;
	default:	goto yy13;
	}
yy15:
#line 94 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                std::cout<<input.tokenText()<<"\n";
                std::cout<<"-----"<<"\n"; 
                continue;
            }
#line 194 "expr_lexer.cpp"
yy16:
	++input.cur;
#line 113 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ 
                    std::cout<<"mod token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_MOD);}
#line 202 "expr_lexer.cpp"
yy18:
	++input.cur;
#line 121 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"open par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_OPENPAR);}
#line 210 "expr_lexer.cpp"
yy20:
	++input.cur;
#line 125 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"close par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_CLOSEPAR);}
#line 218 "expr_lexer.cpp"
yy22:
	yych = *++input.cur;
	switch (yych) {
	case '*':	goto yy51;
	default:	goto yy23;
	}
yy23:
#line 107 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ 
                    std::cout<<"mult token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_MUL);
                }
#line 232 "expr_lexer.cpp"
yy24:
	++input.cur;
#line 100 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ return makeToken(token::OP_ADD);}
#line 237 "expr_lexer.cpp"
yy26:
	++input.cur;
#line 129 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"close par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_COMMA);
                }
#line 246 "expr_lexer.cpp"
yy28:
	++input.cur;
#line 101 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ return makeToken(token::OP_SUB);}
#line 251 "expr_lexer.cpp"
yy30:
	++input.cur;
#line 112 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ return makeToken(token::OP_DIV);}
#line 256 "expr_lexer.cpp"
yy32:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy32;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy41;
	default:	goto yy34;
	}
yy34:
#line 62 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                yylval->emplace<int>(std::strtol(std::string(input.tok, input.cur).c_str(), nullptr,10));
                return makeToken(token::TK_NUMBER);
            }
#line 333 "expr_lexer.cpp"
yy35:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy53;
	default:	goto yy36;
	}
yy36:
#line 139 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"less than token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_LT);
                }
#line 347 "expr_lexer.cpp"
yy37:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy55;
	default:	goto yy38;
	}
yy38:
#line 117 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"assign token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_ASSIGN);}
#line 360 "expr_lexer.cpp"
yy39:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy57;
	default:	goto yy40;
	}
yy40:
#line 134 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"greater than token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_GT);
                }
#line 374 "expr_lexer.cpp"
yy41:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy41;
	default:	goto yy43;
	}
yy43:
#line 66 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                if(input.tokenText().compare("print")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"print token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_PRINT);
                }else if(input.tokenText().compare("input")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"input token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_INPUT);
                }else{
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"ident token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::TK_IDENTIFIER);
                }
            }
#line 466 "expr_lexer.cpp"
yy44:
	++input.cur;
#line 159 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"Not equal token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_NEQ);
                }
#line 475 "expr_lexer.cpp"
yy46:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
yy47:
	switch (yych) {
	case '\n':
	case '(':
	case ')':
	case '|':	goto yy48;
	case '"':	goto yy49;
	default:	goto yy46;
	}
yy48:
	input.cur = input.mark;
	goto yy5;
yy49:
	++input.cur;
#line 87 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                std::cout<<input.tokenText()<<"\n"; 
                std::cout<<"string token\n";
                std::cout<<"-----"<<"\n"; 
                return makeToken(token::TK_STRING);
                }
#line 502 "expr_lexer.cpp"
yy51:
	++input.cur;
#line 102 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ 
                    std::cout<<"pwd token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_PWD);
                    }
#line 511 "expr_lexer.cpp"
yy53:
	++input.cur;
#line 149 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"LET token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_LET);
                }
#line 520 "expr_lexer.cpp"
yy55:
	++input.cur;
#line 154 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"Equal token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_EQ);
                }
#line 529 "expr_lexer.cpp"
yy57:
	++input.cur;
#line 144 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"GET token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_GET);
                }
#line 538 "expr_lexer.cpp"
}
#line 165 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"


        indent_block:
            
#line 545 "expr_lexer.cpp"
{
	char yych;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy62;
	case '\n':	goto yy64;
	case '#':	goto yy66;
	default:	goto yy61;
	}
yy61:
#line 178 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    //input.cur--;
                    //yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                    std::cout<<"text: "<<input.tokenText()<<"\n";
                    std::cout<<"text: "<<input.tokenText()<<"\n";
                    int _spaces = input.tokenText().length();
                    std::cout<<"spaces entrando:" << _spaces << "\n";
                    std::cout<<"pila de espacios:" << spaces.size() << "\n";
                    for(int x = 0; x<spaces.size(); x++){
                        std::cout<<"pos:"<<x<<", text:"<<spaces[x] << "\n";
                    }
                    std::cout<<"flag2\n";

                    if(_spaces > spaces.back()){
                        std::cout<<"flag\n";
                        spaces.push_back(_spaces);
                        std::cout<<"Push:" << _spaces << "\n\n";
                        
                        return makeToken(token::Indent);

                    }else if(_spaces < spaces.back()){
                            while(_spaces != spaces.back()){
                                remaining_tokens.push_back(token::Dedent);
                                std::cout<<"Pop:" << spaces.back() << "\n\n";
                                spaces.pop_back();
                            }
                            //std::cout<<"remaining_dedents size: "<< remaining_dedents.size() << "\n";
                            remaining_tokens.pop_back();
                            return makeToken(token::Dedent);
                    }else{
                        return makeToken(token::NewLine);
                    }
                }
#line 592 "expr_lexer.cpp"
yy62:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy62;
	default:	goto yy61;
	}
yy64:
	++input.cur;
#line 173 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{  std::cout<<"indent_b new line: "<<input.tokenText()<<"\n"; 
                        input.tok = input.cur;
                        goto indent_block;
                    }
#line 609 "expr_lexer.cpp"
yy66:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\n':	goto yy68;
	default:	goto yy66;
	}
yy68:
#line 171 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ continue;}
#line 621 "expr_lexer.cpp"
}
#line 212 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"

    }
}

ExprLexer::input_t::input_t(std::istream &stream)
:input(stream)
{
    buf = new char[SIZE + YYMAXFILL]; //yymaxfill lo trae re2c
    lim = buf + SIZE;  //limite del buffer
    cur = lim; //cursor de YYMARKER
    tok = lim; //apuntador de inicio del lexema
    eof = false; //sentineral de fin del buffer
}

ExprLexer::FillStatus ExprLexer::input_t::fill(size_t need)
{
    if(eof){
        return FillStatus::Eof;
    }
    const size_t free = tok - buf;
    if(free < need)
        return FillStatus::Error;

    memmove(buf,tok, lim - tok);
    lim -= free;
    cur -= free;
    tok -= free;
    lim += input.read(lim,free).gcount();
    if(lim <buf +SIZE){
        eof = true;
        memset(lim,0, YYMAXFILL);
        lim += YYMAXFILL;
    }
    return FillStatus::Ok;
}