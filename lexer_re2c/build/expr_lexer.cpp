/* Generated by re2c 2.0.1 on Sun Aug 23 17:04:59 2020 */
#line 1 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <istream>
#include "lexer.h"

#define YYMAXFILL 2


int ExprLexer::getNextToken(semantic_type *yylval)
{

    #define YYFILL(n) do {\
        FillStatus st = input.fill(n);\
        switch(st){\
            case FillStatus::Eof : return TkEof();\
            case FillStatus::Error : return TkError();\
            default:\
                break;\
        }\
    }while(0)

    
    if(remaining_tokens.size() > 0){
        remaining_tokens.pop_back();
        return makeToken(token::Dedent);
    }

    while(true){
    
    loop:
        input.tok = input.cur;

        
#line 39 "expr_lexer.cpp"
{
	char yych;
	if ((input.lim - input.cur) < 2) YYFILL(2);
	yych = *input.cur;
	switch (yych) {
	case 0x00:	goto yy2;
	case '\t':
	case ' ':	goto yy6;
	case '\n':	goto yy9;
	case '!':	goto yy11;
	case '"':	goto yy12;
	case '#':	goto yy13;
	case '%':	goto yy15;
	case '(':	goto yy17;
	case ')':	goto yy19;
	case '*':	goto yy21;
	case '+':	goto yy23;
	case ',':	goto yy25;
	case '-':	goto yy27;
	case '/':	goto yy29;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy31;
	case '<':	goto yy34;
	case '=':	goto yy36;
	case '>':	goto yy38;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy40;
	default:	goto yy4;
	}
yy2:
	++input.cur;
#line 58 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{return input.eof? TkEof(): TkError();}
#line 132 "expr_lexer.cpp"
yy4:
	++input.cur;
yy5:
#line 50 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{return TkError();}
#line 138 "expr_lexer.cpp"
yy6:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy6;
	default:	goto yy8;
	}
yy8:
#line 59 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{continue;}
#line 151 "expr_lexer.cpp"
yy9:
	++input.cur;
#line 51 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{   
                        //continue;
                        std::cout<<"global newline: "<<input.tokenText();
                        std::cout<<"global newline size: "<<input.tokenText().length() <<"\n";
                        //makeToken(token::TK_EOF);
                        goto indent_block;
                    }
#line 162 "expr_lexer.cpp"
yy11:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy43;
	default:	goto yy5;
	}
yy12:
	yych = *(input.mark = ++input.cur);
	switch (yych) {
	case '\n':
	case '(':
	case ')':
	case '|':	goto yy5;
	default:	goto yy46;
	}
yy13:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\n':	goto yy50;
	default:	goto yy13;
	}
yy15:
	++input.cur;
#line 112 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ 
                    std::cout<<"mod token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_MOD);}
#line 193 "expr_lexer.cpp"
yy17:
	++input.cur;
#line 120 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"open par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_OPENPAR);}
#line 201 "expr_lexer.cpp"
yy19:
	++input.cur;
#line 124 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"close par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_CLOSEPAR);}
#line 209 "expr_lexer.cpp"
yy21:
	yych = *++input.cur;
	switch (yych) {
	case '*':	goto yy52;
	default:	goto yy22;
	}
yy22:
#line 106 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ 
                    std::cout<<"mult token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_MUL);
                }
#line 223 "expr_lexer.cpp"
yy23:
	++input.cur;
#line 99 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ return makeToken(token::OP_ADD);}
#line 228 "expr_lexer.cpp"
yy25:
	++input.cur;
#line 128 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"close par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_COMMA);
                }
#line 237 "expr_lexer.cpp"
yy27:
	++input.cur;
#line 100 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ return makeToken(token::OP_SUB);}
#line 242 "expr_lexer.cpp"
yy29:
	++input.cur;
#line 111 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ return makeToken(token::OP_DIV);}
#line 247 "expr_lexer.cpp"
yy31:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy31;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy40;
	default:	goto yy33;
	}
yy33:
#line 61 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                yylval->emplace<int>(std::strtol(std::string(input.tok, input.cur).c_str(), nullptr,10));
                return makeToken(token::TK_NUMBER);
            }
#line 324 "expr_lexer.cpp"
yy34:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy54;
	default:	goto yy35;
	}
yy35:
#line 138 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"less than token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_LT);
                }
#line 338 "expr_lexer.cpp"
yy36:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy56;
	default:	goto yy37;
	}
yy37:
#line 116 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"assign token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_ASSIGN);}
#line 351 "expr_lexer.cpp"
yy38:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy58;
	default:	goto yy39;
	}
yy39:
#line 133 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"greater than token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_GT);
                }
#line 365 "expr_lexer.cpp"
yy40:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy40;
	default:	goto yy42;
	}
yy42:
#line 65 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                if(input.tokenText().compare("print")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"print token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_PRINT);
                }else if(input.tokenText().compare("input")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"input token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_INPUT);
                }else{
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"ident token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::TK_IDENTIFIER);
                }
            }
#line 457 "expr_lexer.cpp"
yy43:
	++input.cur;
#line 158 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"Not equal token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_NEQ);
                }
#line 466 "expr_lexer.cpp"
yy45:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
yy46:
	switch (yych) {
	case '\n':
	case '(':
	case ')':
	case '|':	goto yy47;
	case '"':	goto yy48;
	default:	goto yy45;
	}
yy47:
	input.cur = input.mark;
	goto yy5;
yy48:
	++input.cur;
#line 86 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                std::cout<<input.tokenText()<<"\n"; 
                std::cout<<"string token\n";
                std::cout<<"-----"<<"\n"; 
                return makeToken(token::TK_STRING);
                }
#line 493 "expr_lexer.cpp"
yy50:
	++input.cur;
#line 93 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                std::cout<<input.tokenText()<<"\n";
                std::cout<<"-----"<<"\n"; 
                continue;
            }
#line 502 "expr_lexer.cpp"
yy52:
	++input.cur;
#line 101 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ 
                    std::cout<<"pwd token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_PWD);
                    }
#line 511 "expr_lexer.cpp"
yy54:
	++input.cur;
#line 148 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"LET token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_LET);
                }
#line 520 "expr_lexer.cpp"
yy56:
	++input.cur;
#line 153 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"Equal token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_EQ);
                }
#line 529 "expr_lexer.cpp"
yy58:
	++input.cur;
#line 143 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    std::cout<<"GET token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_GET);
                }
#line 538 "expr_lexer.cpp"
}
#line 164 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"



        indent_block:
            
#line 546 "expr_lexer.cpp"
{
	char yych;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy64;
	case '\n':	goto yy67;
	default:	goto yy62;
	}
yy62:
	++input.cur;
#line 172 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{ std::cout<<"loop text: "<<input.tokenText()<<"\n";
                    goto loop;}
#line 562 "expr_lexer.cpp"
yy64:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy64;
	default:	goto yy66;
	}
yy66:
#line 175 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{
                    //yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                    std::cout<<"text: "<<input.tokenText()<<"\n";
                    std::cout<<"text: "<<input.tokenText()<<"\n";
                    int _spaces = input.tokenText().length();
                    std::cout<<"spaces entrando:" << _spaces << "\n";
                    std::cout<<"pila de espacios:" << spaces.size() << "\n";
                    for(int x = 0; x<spaces.size(); x++){
                        std::cout<<"pos:"<<x<<", text:"<<spaces[x] << "\n";
                    }
                    std::cout<<"flag2\n";

                    if(_spaces > spaces.back()){
                        std::cout<<"flag\n";
                        spaces.push_back(_spaces);
                        std::cout<<"Push:" << _spaces << "\n\n";
                        
                        return makeToken(token::Indent);

                    }else if(_spaces < spaces.back()){
                            while(_spaces != spaces.back()){
                                remaining_tokens.push_back(token::Dedent);
                                std::cout<<"Pop:" << spaces.back() << "\n\n";
                                spaces.pop_back();
                            }
                            //std::cout<<"remaining_dedents size: "<< remaining_dedents.size() << "\n";
                            remaining_tokens.pop_back();
                            return makeToken(token::Dedent);
                    }else{
                        return makeToken(token::NewLine);
                    }
                }
#line 606 "expr_lexer.cpp"
yy67:
	++input.cur;
#line 208 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"
	{  std::cout<<"indent_b new line: "<<input.tokenText()<<"\n"; 
                        goto indent_block;
                    }
#line 613 "expr_lexer.cpp"
}
#line 212 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c/large_input.re"

    }
}

ExprLexer::input_t::input_t(std::istream &stream)
:input(stream)
{
    buf = new char[SIZE + YYMAXFILL]; //yymaxfill lo trae re2c
    lim = buf + SIZE;  //limite del buffer
    cur = lim; //cursor de YYMARKER
    tok = lim; //apuntador de inicio del lexema
    eof = false; //sentineral de fin del buffer
}

ExprLexer::FillStatus ExprLexer::input_t::fill(size_t need)
{
    if(eof){
        return FillStatus::Eof;
    }
    const size_t free = tok - buf;
    if(free < need)
        return FillStatus::Error;

    memmove(buf,tok, lim - tok);
    lim -= free;
    cur -= free;
    tok -= free;
    lim += input.read(lim,free).gcount();
    if(lim <buf +SIZE){
        eof = true;
        memset(lim,0, YYMAXFILL);
        lim += YYMAXFILL;
    }
    return FillStatus::Ok;
}