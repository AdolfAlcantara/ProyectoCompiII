/* Generated by re2c 2.0.1 on Sun Sep  6 22:32:35 2020 */
#line 1 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <istream>
#include "lexer.h"

#define YYMAXFILL 2


int ExprLexer::getNextToken(semantic_type *yylval)
{

    #define YYFILL(n) do {\
        FillStatus st = input.fill(n);\
        switch(st){\
            case FillStatus::Eof : return TkEof();\
            case FillStatus::Error : return TkError();\
            default:\
                break;\
        }\
    }while(0)

    
    if(remaining_tokens.size() > 0){
        std::cout<<"dedent in stack\n";
        remaining_tokens.pop_back();
        return makeToken(token::Dedent);
    }

    while(true){
    
    loop:
        input.tok = input.cur;

        
#line 40 "expr_lexer.cpp"
{
	char yych;
	if ((input.lim - input.cur) < 2) YYFILL(2);
	yych = *input.cur;
	switch (yych) {
	case 0x00:	goto yy2;
	case '\t':
	case ' ':	goto yy6;
	case '\n':	goto yy9;
	case '!':	goto yy11;
	case '"':
	case '\'':	goto yy12;
	case '#':	goto yy13;
	case '%':	goto yy16;
	case '(':	goto yy18;
	case ')':	goto yy20;
	case '*':	goto yy22;
	case '+':	goto yy24;
	case ',':	goto yy26;
	case '-':	goto yy28;
	case '/':	goto yy30;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy32;
	case ':':	goto yy35;
	case '<':	goto yy37;
	case '=':	goto yy39;
	case '>':	goto yy41;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy43;
	case '[':	goto yy46;
	case ']':	goto yy48;
	default:	goto yy4;
	}
yy2:
	++input.cur;
#line 60 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{return input.eof? TkEof(): TkError();}
#line 137 "expr_lexer.cpp"
yy4:
	++input.cur;
yy5:
#line 51 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{return TkError();}
#line 143 "expr_lexer.cpp"
yy6:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy6;
	default:	goto yy8;
	}
yy8:
#line 61 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{continue;}
#line 156 "expr_lexer.cpp"
yy9:
	++input.cur;
#line 52 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{   
                        //continue;
                        std::cout<<"global newline: "<<input.tokenText();
                        std::cout<<"global newline size: "<<input.tokenText().length() <<"\n";
                        //makeToken(token::TK_EOF);
                        input.tok = input.cur;
                        goto indent_block;
                    }
#line 168 "expr_lexer.cpp"
yy11:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy50;
	default:	goto yy5;
	}
yy12:
	yych = *(input.mark = ++input.cur);
	switch (yych) {
	case '\n':
	case '(':
	case ')':
	case '|':	goto yy5;
	default:	goto yy53;
	}
yy13:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\n':	goto yy15;
	default:	goto yy13;
	}
yy15:
#line 143 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                std::cout<<input.tokenText()<<"\n";
                std::cout<<"-----"<<"\n"; 
                continue;
            }
#line 199 "expr_lexer.cpp"
yy16:
	++input.cur;
#line 162 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ 
                    std::cout<<"mod token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_MOD);}
#line 207 "expr_lexer.cpp"
yy18:
	++input.cur;
#line 170 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"open par token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_OPENPAR);}
#line 215 "expr_lexer.cpp"
yy20:
	++input.cur;
#line 174 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"close par token\n"; 
                    std::cout<<"-----"<<"\n";
                    auto x = makeToken(token::TK_CLOSEPAR);
                    std::cout<<text<<"\n";
                    return x;
                }
#line 226 "expr_lexer.cpp"
yy22:
	yych = *++input.cur;
	switch (yych) {
	case '*':	goto yy57;
	default:	goto yy23;
	}
yy23:
#line 156 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ 
                    std::cout<<"mult token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_MUL);
                }
#line 240 "expr_lexer.cpp"
yy24:
	++input.cur;
#line 149 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ return makeToken(token::OP_ADD);}
#line 245 "expr_lexer.cpp"
yy26:
	++input.cur;
#line 195 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"comma token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_COMMA);
                }
#line 254 "expr_lexer.cpp"
yy28:
	++input.cur;
#line 150 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ return makeToken(token::OP_SUB);}
#line 259 "expr_lexer.cpp"
yy30:
	++input.cur;
#line 161 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ return makeToken(token::OP_DIV);}
#line 264 "expr_lexer.cpp"
yy32:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy32;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy43;
	default:	goto yy34;
	}
yy34:
#line 63 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                yylval->emplace<int>(std::strtol(std::string(input.tok, input.cur).c_str(), nullptr,10));
                std::cout<<"number token\n";
                std::cout<<"-----"<<"\n"; 
                return makeToken(token::TK_NUMBER);
            }
#line 343 "expr_lexer.cpp"
yy35:
	++input.cur;
#line 200 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"colon token\n";
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::TK_COLON);
                }
#line 352 "expr_lexer.cpp"
yy37:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy59;
	default:	goto yy38;
	}
yy38:
#line 210 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"less than token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_LT);
                }
#line 366 "expr_lexer.cpp"
yy39:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy61;
	default:	goto yy40;
	}
yy40:
#line 166 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"assign token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_ASSIGN);}
#line 379 "expr_lexer.cpp"
yy41:
	yych = *++input.cur;
	switch (yych) {
	case '=':	goto yy63;
	default:	goto yy42;
	}
yy42:
#line 205 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"greater than token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_GT);
                }
#line 393 "expr_lexer.cpp"
yy43:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy43;
	default:	goto yy45;
	}
yy45:
#line 69 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                if(input.tokenText().compare("print")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"print token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_PRINT);
                }else if(input.tokenText().compare("input")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"input token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_INPUT);
                }else if(input.tokenText().compare("if")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"if token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_IF);
                }else if(input.tokenText().compare("elif")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"elif token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_ELIF);
                }else if(input.tokenText().compare("else")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"else token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_ELSE);
                }else if(input.tokenText().compare("def")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"def token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_DEF);
                }else if(input.tokenText().compare("return")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"return token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_RETURN);
                }else if(input.tokenText().compare("while")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"while token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_WHILE);
                }else if(input.tokenText().compare("for")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"for token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_FOR);
                }else if(input.tokenText().compare("in")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"in token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_IN);
                }else if(input.tokenText().compare("range")==0){
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"range token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::KW_RANGE);
                }else{
                    std::cout<<"secret word: "<<input.tokenText()<<"\n";
                    std::cout<<"ident token\n";
                    std::cout<<"-----"<<"\n"; 
                    return makeToken(token::TK_IDENTIFIER);
                }
                
            }
#line 531 "expr_lexer.cpp"
yy46:
	++input.cur;
#line 181 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"open bracket token\n"; 
                    std::cout<<"-----"<<"\n";
                    auto x = makeToken(token::TK_OPENBCKT);
                    std::cout<<text<<"\n";
                    return x;
                }
#line 542 "expr_lexer.cpp"
yy48:
	++input.cur;
#line 188 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"close bracket token\n"; 
                    std::cout<<"-----"<<"\n";
                    auto x = makeToken(token::TK_CLOSEBCKT);
                    std::cout<<text<<"\n";
                    return x;
                }
#line 553 "expr_lexer.cpp"
yy50:
	++input.cur;
#line 230 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"Not equal token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_NEQ);
                }
#line 562 "expr_lexer.cpp"
yy52:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
yy53:
	switch (yych) {
	case '\n':
	case '(':
	case ')':
	case '|':	goto yy54;
	case '"':
	case '\'':	goto yy55;
	default:	goto yy52;
	}
yy54:
	input.cur = input.mark;
	goto yy5;
yy55:
	++input.cur;
#line 136 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                std::cout<<input.tokenText()<<"\n"; 
                std::cout<<"string token\n";
                std::cout<<"-----"<<"\n"; 
                return makeToken(token::TK_STRING);
                }
#line 590 "expr_lexer.cpp"
yy57:
	++input.cur;
#line 151 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ 
                    std::cout<<"pwd token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_PWD);
                    }
#line 599 "expr_lexer.cpp"
yy59:
	++input.cur;
#line 220 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"LET token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_LET);
                }
#line 608 "expr_lexer.cpp"
yy61:
	++input.cur;
#line 225 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"Equal token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_EQ);
                }
#line 617 "expr_lexer.cpp"
yy63:
	++input.cur;
#line 215 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    std::cout<<"GET token\n"; 
                    std::cout<<"-----"<<"\n";
                    return makeToken(token::OP_GET);
                }
#line 626 "expr_lexer.cpp"
}
#line 236 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"


        indent_block:
            
#line 633 "expr_lexer.cpp"
{
	char yych;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy68;
	case '\n':	goto yy70;
	case '#':	goto yy72;
	default:	goto yy67;
	}
yy67:
#line 249 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{
                    //input.cur--;
                    //yylval->emplace<std::string>(std::string(input.tok, input.cur).c_str(),std::string(input.tok, input.cur).size());
                    //std::cout<<"text: "<<input.tokenText()<<"\n";
                    //std::cout<<"text: "<<input.tokenText()<<"\n";
                    int _spaces = input.tokenText().length();
                    std::cout<<"spaces entrando:" << _spaces << "\n";
                    std::cout<<"pila de espacios:" << spaces.size() << "\n";
                    for(int x = 0; x<spaces.size(); x++){
                        std::cout<<"pos:"<<x<<", text:"<<spaces[x] << "\n";
                    }
                    

                    if(_spaces > spaces.back()){
                        std::cout<<"flag\n";
                        spaces.push_back(_spaces);
                        std::cout<<"Push:" << _spaces << "\n\n";

                        std::cout<<"indent token\n"; 
                        std::cout<<"-----"<<"\n";    
                        return makeToken(token::Indent);

                    }else if(_spaces < spaces.back()){
                            while(_spaces != spaces.back()){
                                remaining_tokens.push_back(token::Dedent);
                                std::cout<<"Pop:" << spaces.back() << "\n\n";
                                spaces.pop_back();
                            }
                            //std::cout<<"remaining_dedents size: "<< remaining_dedents.size() << "\n";
                            remaining_tokens.pop_back();
                            std::cout<<"Dedent token\n"; 
                            std::cout<<"-----"<<"\n";    
                            return makeToken(token::Dedent);
                    }else{
                        std::cout<<"newline token\n"; 
                        std::cout<<"-----"<<"\n";    
                        return makeToken(token::NewLine);
                    }
                }
#line 686 "expr_lexer.cpp"
yy68:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\t':
	case ' ':	goto yy68;
	default:	goto yy67;
	}
yy70:
	++input.cur;
#line 244 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{  std::cout<<"indent_b new line: "<<input.tokenText()<<"\n"; 
                        input.tok = input.cur;
                        goto indent_block;
                    }
#line 703 "expr_lexer.cpp"
yy72:
	++input.cur;
	if (input.lim <= input.cur) YYFILL(1);
	yych = *input.cur;
	switch (yych) {
	case '\n':	goto yy74;
	default:	goto yy72;
	}
yy74:
#line 242 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"
	{ continue;}
#line 715 "expr_lexer.cpp"
}
#line 289 "/home/deafdead/Documentos/compiII/proyecto/lexer_re2c_ast/large_input.re"

    }
}

ExprLexer::input_t::input_t(std::istream &stream)
:input(stream)
{
    buf = new char[SIZE + YYMAXFILL]; //yymaxfill lo trae re2c
    lim = buf + SIZE;  //limite del buffer
    cur = lim; //cursor de YYMARKER
    tok = lim; //apuntador de inicio del lexema
    eof = false; //sentineral de fin del buffer
}

ExprLexer::FillStatus ExprLexer::input_t::fill(size_t need)
{
    if(eof){
        return FillStatus::Eof;
    }
    const size_t free = tok - buf;
    if(free < need)
        return FillStatus::Error;

    memmove(buf,tok, lim - tok);
    lim -= free;
    cur -= free;
    tok -= free;
    lim += input.read(lim,free).gcount();
    if(lim <buf +SIZE){
        eof = true;
        memset(lim,0, YYMAXFILL);
        lim += YYMAXFILL;
    }
    return FillStatus::Ok;
}