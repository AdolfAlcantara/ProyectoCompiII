%option lang = "C++"
%option namespace = "Ast"
// %option reentrant

//va en el header
%decls %{
#include <string>
#include <cstddef>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <math.h> 
#include "Auxiliar.h"

using string_t = std::string;

namespace Ast
{
    class Node;
    using NodeVector = std::vector<Node*>;
    using SymbolTable = std::unordered_map<std::string, int>;
    using SymbolTableGen = std::unordered_map<std::string, std::string>;
}
%}

//esto va para el cpp
%{
    #include "expr_ast.h"
    Auxiliar aux;
%}

%node Node %abstract %typedef = {
    %nocreate string_t code;
    %nocreate int place;
}

%node Expr Node %abstract

%node BinaryExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node NumExpr Expr = {
    int value;
}

%node IdExpr Expr = {
    string_t id;
}

%node InputExpr Expr = {
    string_t text;
}

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MulExpr BinaryExpr
%node DivExpr BinaryExpr
%node ModExpr BinaryExpr
%node PwdExpr BinaryExpr
%node GTExpr BinaryExpr
%node LTExpr BinaryExpr
%node GEExpr BinaryExpr
%node LEExpr BinaryExpr
%node EqExpr BinaryExpr
%node NotExpr BinaryExpr

%node Stmt Node %abstract

%node AssignStmt Stmt = {
    string_t id;
    Expr * expr;
}

%node StmtList Node = {
    BlockStmt *funcs;
    BlockStmt *stmts;   
}

%node BlockStmt Stmt = {
    NodeVector l;
}

%node ArgList Expr = {
    NodeVector args;
}

%node ForStmt Stmt = {
    string_t id;
    ArgList * args;
    Stmt * blck_stmts;
}

%node PrintList Stmt = {
    NodeVector vals;
}

%node PrintExpr Stmt = {
    Expr * expr;
}

%node PrintString Stmt = {
    string_t literal;
}

%node IfStmt Stmt = {
    Expr * cond;
    Stmt * true_blk;
    Stmt * false_blk;
}

%node ElseStmt Stmt = {
    Stmt *  code_blk;
}

%node WhileStmt Stmt = {
    Expr *cond;
    Stmt *block;
}

%node FuncDecl Stmt = {
    string_t name;
    ArgList * args;
    Stmt *  code_blk;
}

%node FuncCall Expr = {
    string_t name;
    ArgList *args;
}

%node ReturnStmt Stmt = {
    Expr *expr;
} 

%node ArrayDecl Stmt = {
    string_t name;
    ArgList * args;
}

%node ArrayStmt Stmt = {
    string_t name;
    Expr *exprPos;
    Expr *exprRHS;
}

%node ArrayExpr Expr = {
    string_t name;
    Expr *exprPos;
}

%operation %virtual int eval(Node *this, SymbolTable& vars);

eval(AddExpr) { return expr1->eval(vars) + expr2->eval(vars);}
eval(SubExpr) { return expr1->eval(vars) - expr2->eval(vars);}
eval(MulExpr) { return expr1->eval(vars) * expr2->eval(vars);}
eval(DivExpr) { return expr1->eval(vars) / expr2->eval(vars);}
eval(ModExpr) { return expr1->eval(vars) % expr2->eval(vars);}
eval(PwdExpr) { return pow(expr1->eval(vars), expr2->eval(vars));}
eval(GTExpr) { return expr1->eval(vars) > expr2->eval(vars);}
eval(LTExpr) { return expr1->eval(vars) < expr2->eval(vars);}
eval(GEExpr) { return expr1->eval(vars) >= expr2->eval(vars);}
eval(LEExpr) { return expr1->eval(vars) <= expr2->eval(vars);}
eval(EqExpr) { return expr1->eval(vars) == expr2->eval(vars);}
eval(NotExpr) { return expr1->eval(vars) != expr2->eval(vars);}

eval(NumExpr){
    return value;
}

eval(IdExpr){
    auto it = vars.find(id);

    if(it != vars.end())
        return it->second;
    else
        throw std::exception();
}

eval(InputExpr){
    //std::cout<<text;
    int val;
    std::cin>>val;
    return val;
}

eval(ArrayDecl){
    return 0;
}

eval(ArrayStmt){
    return 0;
}

eval(ArrayExpr){
    return 0;
}

eval(AssignStmt){
    int value = expr->eval(vars);
    vars[id] = value;

    return 0;
}

eval(StmtList){
    return 0;
}

eval(BlockStmt){
    for(const auto& stmt : l){
        stmt->eval(vars);
    }

    return 0;
}

eval(ArgList){
    for(const auto& arg : args){
        arg->eval(vars);
    }
    return 0; 
}

eval(ForStmt){

    return 0;
}

eval(PrintExpr){
    return 0;
}

eval(PrintString){
    return 0;
}

eval(PrintList){
    for(const auto& p : vals){
        p->eval(vars);
    }
    //std::cout<<std::endl;
    return 0;
}

eval(IfStmt){
    if(cond->eval(vars))
        true_blk->eval(vars);
    else if(false_blk != nullptr)
        false_blk->eval(vars);

    return 0;
}

eval(ElseStmt){
    if(code_blk != nullptr){
        code_blk->eval(vars);
    }
    return 0;
}

eval(WhileStmt){
    while(cond->eval(vars))
        block->eval(vars);
    return 0;
}

eval(FuncDecl){
    return 0;
}

eval(FuncCall){
    return 0;
}

eval(ReturnStmt){
    return 0;
}

%operation %virtual int gen(Node *this, SymbolTableGen& vars);

gen(AddExpr)
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "add\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";

    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(SubExpr)
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "sub\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";

    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(MulExpr)
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "mult\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n\n";
    code += "mflo\t\t $t"+aux.to_str(place)+"\n";
    
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(DivExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "div\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n\n";
    code += "mflo\t\t $t"+aux.to_str(place)+"\n";
    
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);   
    
    return 0;
}
gen(ModExpr)
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "div\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n\n";
    code += "mfhi\t\t $t"+aux.to_str(place)+"\n";
    
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);   
        
    return 0;
}
gen(PwdExpr) 
{
    int place = aux.getReg();
    code = "";
    if(expr1->getKindName() == "NumExpr" && expr2->getKindName() == "NumExpr")
    {
        int res = pow(reinterpret_cast<Ast::NumExpr*>(expr1)->value, reinterpret_cast<Ast::NumExpr*>(expr2)->value);
        code += "li\t\t $t"+aux.to_str(place)+", "+aux.to_str(res)+"\n\n";

    }else if(expr2->getKindName() == "NumExpr")
    {
        if(reinterpret_cast<Ast::NumExpr*>(expr2)->value == 0){
            code += "li\t\t $t"+aux.to_str(place)+", 1";
        }else if(reinterpret_cast<Ast::NumExpr*>(expr2)->value == 1){
            expr1->gen(vars);
            code += expr1->code;
            code += "move\t\t $t"+aux.to_str(place)+",$t"+aux.to_str(expr1->place)+"\n";
            aux.freeReg(expr1->place);
        }else{
            expr1->gen(vars);
            expr2->gen(vars);

            std::string pwd_label = aux.labelGenerator("pwd");
            std::string pwd_end_label = aux.labelGenerator("pwd");
            code += expr1->code + expr2->code;
            code += "li\t\t $t"+aux.to_str(place)+", 1\n";

            code += pwd_label+":\n";
            code += "beq\t\t $t"+aux.to_str(expr2->place)+",$zero, "+pwd_end_label+"\n";
            code += "mult\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+"\n";
            code += "mflo\t\t $t"+aux.to_str(place)+"\n\n";
            code += "addi\t\t $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr2->place)+", -1\n";
            code += "j\t\t "+pwd_label+"\n";

            code+= pwd_end_label+":\n";

            aux.freeReg(expr1->place);
            aux.freeReg(expr2->place);
        }
    }else{
        expr1->gen(vars);
        expr2->gen(vars);
        std::string pwd_label = aux.labelGenerator("pwd");
        std::string pwd_end_label = aux.labelGenerator("pwd");
        code += expr1->code + expr2->code;
        code += "li\t\t $t"+aux.to_str(place)+", 1\n";

        code += pwd_label+":\n";
        code += "beq\t\t $t"+aux.to_str(expr2->place)+",$zero, "+pwd_end_label+"\n";
        code += "mult\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+"\n";
        code += "mflo\t\t $t"+aux.to_str(place)+"\n\n";
        code += "addi\t\t $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr2->place)+", -1\n";
        code += "j\t\t "+pwd_label+"\n";

        code+= pwd_end_label+":\n";

        aux.freeReg(expr1->place);
        aux.freeReg(expr2->place);
    }
    return 0;
}

gen(GTExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();
    code = expr1->code + expr2->code;
    code+="slt\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr1->place)+"\n";
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(LTExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();
    code = expr1->code + expr2->code;
    code+="slt\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n";
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(GEExpr) {

    expr1->gen(vars);
    expr2->gen(vars);

    code = expr1->code + expr2->code;
    int gt = aux.getReg();
    code+="slt\t\t $t"+aux.to_str(gt)+", $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr1->place)+"\n";

    int eq = aux.getReg();
    code += "sub\t\t $t"+aux.to_str(eq)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";
    code += "slt\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(eq)+", $zero\n";
    code += "slt\t\t $t"+aux.to_str(expr2->place)+", $zero, $t"+aux.to_str(eq)+"\n";
    code += "xori\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr1->place)+", 1\n";
    code += "xori\t\t $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr2->place)+", 0\n";
    code += "xor\t\t $t"+aux.to_str(eq)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n";

    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    place = aux.getReg();

    code += "or\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(gt)+", $t"+aux.to_str(eq)+"\n";
    

    return 0;
}

gen(LEExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    code = expr1->code + expr2->code;
    int lt = aux.getReg();
    code+="slt\t\t $t"+aux.to_str(lt)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n";

    int eq = aux.getReg();
    code += "sub\t\t $t"+aux.to_str(eq)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";
    code += "slt\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(eq)+", $zero\n";
    code += "slt\t\t $t"+aux.to_str(expr2->place)+", $zero, $t"+aux.to_str(eq)+"\n";
    code += "xori\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr1->place)+", 1\n";
    code += "xori\t\t $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr2->place)+", 0\n";
    code += "xor\t\t $t"+aux.to_str(eq)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n";

    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    place = aux.getReg();

    code += "or\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(lt)+", $t"+aux.to_str(eq)+"\n";
    
    return 0;
}

gen(EqExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "sub\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";
    code += "slt\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(place)+", $zero\n";
    code += "slt\t\t $t"+aux.to_str(expr2->place)+", $zero, $t"+aux.to_str(place)+"\n";
    code += "xori\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr1->place)+", 1\n";
    code += "xori\t\t $t"+aux.to_str(expr2->place)+", $t"+aux.to_str(expr2->place)+", 0\n";
    code += "xor\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n";
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(NotExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "sub\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";
    code += "slt\t\t $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(place)+", $zero\n";
    code += "slt\t\t $t"+aux.to_str(expr2->place)+", $zero, $t"+aux.to_str(place)+"\n";
    code += "xor\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place)+"\n";
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
    
}


gen(NumExpr)
{
    place = aux.getReg();

    code = "li\t\t $t"+aux.to_str(place)+", "+aux.to_str(value) + "\n";
    return 0;
}

gen(IdExpr){
    //std::cout<<"IdExpr:"<<id<<"\n";
    place  = aux.getReg();
    //std::cout<<"Reg:"<<place<<"\n";
    code = "la\t\t $t"+aux.to_str(place)+", "+id+"\n";
    code += "lw\t\t $t"+aux.to_str(place)+", 0($t"+aux.to_str(place)+")\n";
    return 0;
}

gen(InputExpr){
    place = aux.getReg();
    string_t var = aux.saveVar(vars,text,2);
    code="";
    // code = "addi\t\t $sp, $sp, -4\n";
    code += "sw\t\t $ra, 0($sp)\n";
    
    code += "la\t\t $a0,"+var+"\n";
    code += "jal\t\t print_str\n";
    code += "jal read_int\n";
    code+= "move\t\t $t"+aux.to_str(place)+", $v0\n";

    code += "lw\t\t $ra, 0($sp)\n";
    // code += "addi\t\t $sp, $sp, 4\n";
    return 0;
}

gen(AssignStmt){
    expr->gen(vars);

    place = aux.getReg();
    aux.saveVar(vars,id,1);
    code = expr->code;
    code += "la\t\t $t"+aux.to_str(place)+", "+id+"\n";
    code += "sw\t\t $t"+aux.to_str(expr->place)+", 0($t"+aux.to_str(place)+")\n";

    aux.freeReg(expr->place);
    return 0;
}

gen(StmtList){
    code = "";
    if(funcs != nullptr){
        funcs->gen(vars);
        code+= funcs->code;
    }

    code+="\nmain:\n";
    code+="addi\t\t $sp, $sp, -4\n";
    stmts->gen(vars);
    code+= stmts->code;
    code+="addi\t\t $sp, $sp, 4\n";
    code+="jr\t\t $ra\n";
    return 0;
}

gen(BlockStmt){
    code = "";
    for(const auto& stmt : l){
        stmt->gen(vars);
        code += stmt->code;
        aux.freeReg(stmt->place);
    }

    return 0;
}

gen(ArgList){
    code ="";
    for(const auto& arg : args){
        int x = aux.getArg();
        arg->gen(vars);
        code+=arg->code;
        code+="move\t\t $a"+aux.to_str(x)+", $t"+aux.to_str(arg->place)+"\n";
        aux.freeReg(arg->place);
    }
    aux.freeArgs();
    return 0; 
}

gen(ForStmt){
    args->gen(vars);
    code = args->code;
    int start = aux.getReg();
    int end = aux.getReg();
    code+= "move\t\t $t"+aux.to_str(start)+", $a0\n";
    code+= "move\t\t $t"+aux.to_str(end)+", $a1\n";
    aux.saveVar(vars,id,1);
    int temp = aux.getReg();
    code += "la\t\t $t"+aux.to_str(temp)+", "+id+"\n";
    code += "sw\t\t $t"+aux.to_str(start)+", 0($t"+aux.to_str(temp)+")\n";
    aux.freeReg(temp);
    aux.freeReg(start);

    std::string label_for = aux.labelGenerator("for");
    std::string label_end_for = aux.labelGenerator("end_for");
    code += label_for+":\n\n";
    temp = aux.getReg();
    int _i = aux.getReg();
    code += "la\t\t $t"+aux.to_str(_i)+", "+id+"\n";
    code += "lw\t\t $t"+aux.to_str(_i)+", 0($t"+aux.to_str(_i)+")\n";
    code += "slt\t\t $t"+aux.to_str(temp)+", $t"+aux.to_str(_i)+", $t"+aux.to_str(end)+"\n";
    code += "beq\t\t $t"+aux.to_str(temp)+", $zero, "+label_end_for+"\n\n";
    aux.freeReg(temp);
    aux.freeReg(_i);

    blck_stmts->gen(vars);
    code += blck_stmts->code;

    _i = aux.getReg();
    code += "la\t\t $t"+aux.to_str(_i)+", "+id+"\n";
    code += "lw\t\t $t"+aux.to_str(_i)+", 0($t"+aux.to_str(_i)+")\n";
    code += "addi\t\t $t"+aux.to_str(_i)+", $t"+aux.to_str(_i)+", 1\n";
    temp = aux.getReg();
    code += "la\t\t $t"+aux.to_str(temp)+", "+id+"\n";
    code += "sw\t\t $t"+aux.to_str(_i)+", 0($t"+aux.to_str(temp)+")\n";
    aux.freeReg(temp);
    aux.freeReg(_i);
    code+="j\t\t "+label_for+"\n";

    code+="\n"+label_end_for+":\n\n";
    aux.freeReg(start);
    aux.freeReg(end);
    return 0;
}

gen(PrintList){
    code = "";
    for(const auto& val : vals){
        val->gen(vars);
        code += val->code;
    }
    return 0;
}

gen(PrintExpr)
{ 
    expr->gen(vars);

    code = expr->code;
    // code += "addi\t\t $sp, $sp, -4\n";
    code += "sw\t\t $ra, 0($sp)\n";

    code+= "move\t\t $a0,$t"+aux.to_str(expr->place)+"\n";
    code+= "jal\t\t print_int\n";
    code+= "li\t\t $a0, 10\n";
    code+= "jal\t\t print_char\n";

    code += "lw\t\t $ra, 0($sp)\n";
    // code += "addi\t\t $sp, $sp, 4\n";

    aux.freeReg(expr->place);
    return 0;
}

gen(PrintString)
{
    string_t var = aux.saveVar(vars,literal,2);
    // code = "addi\t\t $sp, $sp, -4\n";
    code += "sw\t\t $ra, 0($sp)\n";

    code += "la\t\t $a0,"+var+"\n";
    code+= "jal\t\t print_str\n";
    code+= "li\t\t $a0, 10\n";
    code+= "jal\t\t print_char\n";
    
    code += "lw\t\t $ra, 0($sp)\n";
    // code += "addi\t\t $sp, $sp, 4\n";
    return 0;
}

gen(IfStmt)
{
    cond->gen(vars);
    code = cond->code;
    std::string label_if = aux.labelGenerator("if");
    std::string label_else = aux.labelGenerator("else");
    std::string label_end_if = aux.labelGenerator("end_if");
    code+= "\n"+label_if+":\n\n";
    code+= "beq\t\t $t"+aux.to_str(cond->place)+", $zero, "+label_else +"\n";
    aux.freeReg(cond->place);

    true_blk->gen(vars);
    code+= true_blk->code;
    code+= "j\t\t "+label_end_if+"\n\n";

    code+=label_else+":\n\n";
    if(false_blk != nullptr){
        false_blk->gen(vars);
        code+= false_blk->code;
    }

    code+= label_end_if+":\n\n";

    return 0;
}

gen(ElseStmt)
{
    if(code_blk != nullptr){
        code_blk->gen(vars);
        code+= code_blk->code;
    }
    return 0;
}

gen(WhileStmt)
{
    std::string label_while = aux.labelGenerator("while");
    code = "\n"+label_while+":\n";
    cond->gen(vars);
    code += cond->code;

    std::string label_end_while = aux.labelGenerator("while_end");
    code += "beq\t\t $t"+aux.to_str(cond->place)+", $zero, "+label_end_while+"\n";

    aux.freeReg(cond->place);
    block->gen(vars);

    code += block->code;

    code += "j\t\t "+label_while+"\n";
    
    code += "\n"+label_end_while+":\n";

    return 0;
}

gen(FuncDecl)
{
    int parameter_count = 0;
    code = "";
    std::string label_func = aux.labelGenerator(name);
    aux.saveLabel(name, label_func); 

    code+= "\n"+label_func+":\n\n";

    code+= "addi\t\t $sp, $sp, -4\n";
    

    for(const auto& arg : args->args){
        std::string parameter = reinterpret_cast<Ast::IdExpr*>(arg)->id;
        
        aux.saveVar(vars,parameter,1);
        int temp = aux.getReg();
        code+= "la\t\t $t"+aux.to_str(temp)+", "+parameter+"\n";
        code+= "sw\t\t $a"+aux.to_str(parameter_count++)+", 0($t"+aux.to_str(temp)+")\n";
        aux.freeReg(temp);
    }
    
    code_blk->gen(vars);
    code += code_blk->code;
    code += "addi\t\t $sp, $sp, 4\n";
    code += "jr\t\t $ra\n\n";
    return 0;
}

gen(FuncCall){
    args->gen(vars);
    code = args->code;
    std::string _name = aux.getLabel(name);
    // code += "addi\t\t $sp, $sp, -4\n";
    code += "sw\t\t $ra, 0($sp)\n";
    code += "jal\t\t "+_name+"\n\n";
    code += "lw\t\t $ra, 0($sp)\n";
    place = aux.getReg();
    code += "move\t\t $t"+aux.to_str(place)+", $v0\n\n";
    // code += "addi\t\t $sp, $sp, 4\n";
    return 0;
}

gen(ReturnStmt){
    expr->gen(vars);

    code = expr->code;
    code += "move\t\t $v0, $t"+aux.to_str(expr->place)+"\n";
    code += "addi\t\t $sp, $sp, 4\n";
    code += "jr\t\t $ra\n\n";
    aux.freeReg(expr->place);
    return 0;
}

gen(ArrayDecl){
    std::string tempCode = "";
    int spaces = 0;
    for(const auto& arg : args->args){
        int offset = spaces * 4;
        offset += 4;
        arg->gen(vars);
        tempCode+= arg->code;
        tempCode+="sw\t\t $t"+aux.to_str(arg->place)+", "+aux.to_str(offset)+"($sp)\n";
        aux.freeReg(arg->place);
        spaces++;
    }
    aux.saveArrayRange(spaces);
    aux.saveVar(vars,name,1);
    code = "addi\t\t $sp, $sp, -"+aux.to_str(spaces*4)+"\n\n";
    code += tempCode;
    int array_addr = aux.getReg();
    code+= "la $t"+aux.to_str(array_addr)+", "+name+"\n";
    code+= "sw $sp, 0($t"+aux.to_str(array_addr)+")\n\n";
    return 0;
}

gen(ArrayStmt){
    exprPos->gen(vars);

    code = exprPos->code;
    code += "sll\t\t $t"+aux.to_str(exprPos->place)+", $t"+aux.to_str(exprPos->place)+", 2\n";
    code += "addi\t\t $t"+aux.to_str(exprPos->place)+",$t"+aux.to_str(exprPos->place)+", 4\n";
    int address = aux.getReg();
    code += "la\t\t $t"+aux.to_str(address)+", "+name+"\n";
    code += "lw\t\t $t"+aux.to_str(address)+", 0($t"+aux.to_str(address)+")\n";
    code += "add\t\t $t"+aux.to_str(address)+", $t"+aux.to_str(exprPos->place)+", $t"+aux.to_str(address)+"\n\n";

    aux.freeReg(exprPos->place);
    exprRHS->gen(vars);

    code+= exprRHS->code;
    code+= "sw\t\t $t"+aux.to_str(exprRHS->place)+", 0($t"+aux.to_str(address)+")\n\n";
    aux.freeReg(exprRHS->place);
    aux.freeReg(address);

    return 0;
}

gen(ArrayExpr){
    exprPos->gen(vars);

    code = exprPos->code;
    code += "sll\t\t $t"+aux.to_str(exprPos->place)+", $t"+aux.to_str(exprPos->place)+", 2\n";
    code += "addi\t\t $t"+aux.to_str(exprPos->place)+",$t"+aux.to_str(exprPos->place)+", 4\n";
    int address = aux.getReg();
    code += "la\t\t $t"+aux.to_str(address)+", "+name+"\n";
    code += "lw\t\t $t"+aux.to_str(address)+", 0($t"+aux.to_str(address)+")\n";
    code += "add\t\t $t"+aux.to_str(address)+", $t"+aux.to_str(exprPos->place)+", $t"+aux.to_str(address)+"\n\n";

    place = aux.getReg();
    code += "lw $t"+aux.to_str(place)+", 0($t"+aux.to_str(address)+")\n\n";
    aux.freeReg(address);
    return 0;
}