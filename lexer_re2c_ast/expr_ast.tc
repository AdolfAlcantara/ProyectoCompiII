%option lang = "C++"
%option namespace = "Ast"
// %option reentrant

//va en el header
%decls %{
#include <string>
#include <cstddef>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <math.h> 
#include "Auxiliar.h"

using string_t = std::string;

namespace Ast
{
    class Node;
    using NodeVector = std::vector<Node*>;
    using SymbolTable = std::unordered_map<std::string, int>;
    using SymbolTableGen = std::unordered_map<std::string, std::string>;
}
%}

//esto va para el cpp
%{
    #include "expr_ast.h"
    Auxiliar aux;
%}

%node Node %abstract %typedef = {
    %nocreate string_t code;
    %nocreate int place;
}

%node Expr Node %abstract

%node BinaryExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node NumExpr Expr = {
    int value;
}

%node IdExpr Expr = {
    string_t id;
}

%node InputExpr Expr = {
    string_t text;
}

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MulExpr BinaryExpr
%node DivExpr BinaryExpr
%node ModExpr BinaryExpr
%node PwdExpr BinaryExpr
%node GTExpr BinaryExpr
%node LTExpr BinaryExpr
%node GEExpr BinaryExpr
%node LEExpr BinaryExpr
%node EqExpr BinaryExpr
%node NotExpr BinaryExpr

%node Stmt Node %abstract

%node AssignStmt Stmt = {
    string_t id;
    Expr * expr;
}

%node BlockStmt Stmt = {
    NodeVector l;
}

%node ArgList Expr = {
    NodeVector args;
}

%node ForStmt Stmt = {
    string_t id;
    ArgList * args;for(int i=0;i<10;i++){
        //     std::cout<<to_str(i)+": "<<regs[i]<<"\n";
        // }
    Stmt * blck_stmts;
}

%node PrintList Stmt = {
    NodeVector vals;
}

%node PrintExpr Stmt = {
    Expr * expr;
}

%node PrintString Stmt = {
    string_t literal;
}

%node IfStmt Stmt = {
    Expr * cond;
    Stmt * true_blk;
    Stmt * false_blk;
}

%node ElseStmt Stmt = {
    Stmt *  code_blk;
}

%node WhileStmt Stmt = {
    Expr *cond;
    Stmt *block;
}

%operation %virtual int eval(Node *this, SymbolTable& vars);

eval(AddExpr) { return expr1->eval(vars) + expr2->eval(vars);}
eval(SubExpr) { return expr1->eval(vars) - expr2->eval(vars);}
eval(MulExpr) { return expr1->eval(vars) * expr2->eval(vars);}
eval(DivExpr) { return expr1->eval(vars) / expr2->eval(vars);}
eval(ModExpr) { return expr1->eval(vars) % expr2->eval(vars);}
eval(PwdExpr) { return pow(expr1->eval(vars), expr2->eval(vars));}
eval(GTExpr) { return expr1->eval(vars) > expr2->eval(vars);}
eval(LTExpr) { return expr1->eval(vars) < expr2->eval(vars);}
eval(GEExpr) { return expr1->eval(vars) >= expr2->eval(vars);}
eval(LEExpr) { return expr1->eval(vars) <= expr2->eval(vars);}
eval(EqExpr) { return expr1->eval(vars) == expr2->eval(vars);}
eval(NotExpr) { return expr1->eval(vars) != expr2->eval(vars);}

eval(NumExpr){
    return value;
}

eval(IdExpr){
    auto it = vars.find(id);

    if(it != vars.end())
        return it->second;
    else
        throw std::exception();
}

eval(InputExpr){
    std::cout<<text;
    int val;
    std::cin>>val;
    return val;
}

eval(AssignStmt){
    int value = expr->eval(vars);
    vars[id] = value;

    return 0;
}

eval(BlockStmt){
    for(const auto& stmt : l){
        stmt->eval(vars);
    }

    return 0;
}

eval(ArgList){
    for(const auto& arg : args){
        arg->eval(vars);
    }
    return 0; 
}

eval(ForStmt){
    // int second = args->args.back()->eval(vars);
    // std::cout<<"second: "<<second<<std::endl;
    // args->args.pop_back();
    // int first = args->args.back()->eval(vars);
    // std::cout<<"first: "<<first<<std::endl;
    // vars[id] = first;
    // int i = first;
    // for(;i<second;){
    //     blck_stmts->eval(vars);
    //     i++;
    //     vars[id] = i;
    // }
    return 0;
}

eval(PrintExpr){
    std::cout << expr->eval(vars);
    return 0;
}

eval(PrintString){
    std::cout<<literal;
    return 0;
}

eval(PrintList){
    for(const auto& p : vals){
        p->eval(vars);
    }
    std::cout<<std::endl;
    return 0;
}

eval(IfStmt){
    if(cond->eval(vars))
        true_blk->eval(vars);
    else if(false_blk != nullptr)
        false_blk->eval(vars);

    return 0;
}

eval(ElseStmt){
    if(code_blk != nullptr){
        code_blk->eval(vars);
    }
    return 0;
}

eval(WhileStmt){
    while(cond->eval(vars))
        block->eval(vars);
    return 0;
}

%operation %virtual int gen(Node *this, SymbolTableGen& vars);

gen(AddExpr)
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "add\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";

    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(SubExpr)
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();

    code = expr1->code + expr2->code;
    code += "sub\t\t $t"+aux.to_str(place)+", $t"+aux.to_str(expr1->place)+", $t"+aux.to_str(expr2->place) + "\n";

    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}

gen(MulExpr) {return 0;}
gen(DivExpr) {return 0;}
gen(ModExpr) {return 0;}
gen(PwdExpr) {return 0;}
gen(GTExpr) 
{
    expr1->gen(vars);
    expr2->gen(vars);

    place = aux.getReg();
    code = expr1->code + expr2->code;
    code+="slt\t\t $t"+aux.to_str(place)+", $t"+expr2->place+", $t"+expr1->place+"\n";
    aux.freeReg(expr1->place);
    aux.freeReg(expr2->place);
    return 0;
}
gen(LTExpr) 
{
    return 0;
}
gen(GEExpr) {return 0;}
gen(LEExpr) {return 0;}
gen(EqExpr) {return 0;}
gen(NotExpr) {return 0;}


gen(NumExpr)
{
    place = aux.getReg();

    code = "li\t\t $t"+aux.to_str(place)+", "+aux.to_str(value) + "\n";
    return 0;
}

gen(IdExpr){
    std::cout<<"IdExpr:\n";
    place  = aux.getReg();
    
    code = "la\t\t $t"+aux.to_str(place)+", "+id+"\n";
    code += "lw\t\t $t"+aux.to_str(place)+", 0($t"+aux.to_str(place)+")\n";
    return 0;
}

gen(InputExpr){
    place = aux.getReg();
    
    code = "jal read_int\n";
    code+= "move\t\t $t"+aux.to_str(place)+", $v0\n";
    return 0;
}

gen(AssignStmt){
    expr->gen(vars);

    place = aux.getReg();
    std::cout<<"flag\n";
    aux.saveVar(vars,id,1);
    std::cout<<"flag5\n";
    code = expr->code;
    code += "la\t\t $t"+aux.to_str(place)+", "+id+"\n";
    code += "sw\t\t $t"+aux.to_str(expr->place)+", 0($t"+aux.to_str(place)+")\n";

    aux.freeReg(expr->place);
    return 0;
}

gen(BlockStmt){
    code = "";
    for(const auto& stmt : l){
        stmt->gen(vars);
        code += stmt->code;
    }

    return 0;
}

gen(ArgList){
    code ="";
    for(const auto& arg : args){
        int x = aux.getArg();
        arg->gen(vars);
        code+=arg->code;
        code+="move\t\t $a"+aux.to_str(x)+", $t"+aux.to_str(arg->place)+"\n";
        aux.freeReg(arg->place);
    }
    aux.freeArgs();
    return 0; 
}

gen(ForStmt){
    args->gen(vars);
    code = args->code;
    int start = aux.getReg();
    int end = aux.getReg();
    code+= "move\t\t $t"+aux.to_str(start)+", $a0\n";
    code+= "move\t\t $t"+aux.to_str(end)+", $a1\n";
    aux.saveVar(vars,id,1);
    int temp = aux.getReg();
    code += "la\t\t $t"+aux.to_str(temp)+", "+id+"\n";
    code += "sw\t\t $t"+aux.to_str(start)+", 0($t"+aux.to_str(temp)+")\n";
    aux.freeReg(temp);

    std::string label_for = aux.labelGenerator("for");
    std::string label_end_for = aux.labelGenerator("end_for");
    code += label_for+":\n\n";
    temp = aux.getReg();
    code += "slt\t\t $t"+aux.to_str(temp)+", $t"+aux.to_str(start)+", $t"+aux.to_str(end)+"\n";
    code += "beq\t\t $t"+aux.to_str(temp)+", $zero, "+label_end_for+"\n\n";
    aux.freeReg(temp);
    blck_stmts->gen(vars);
    code += blck_stmts->code;

    code += "addi\t\t $t"+aux.to_str(start)+", $t"+aux.to_str(start)+", 1\n";
    temp = aux.getReg();
    code += "la\t\t $t"+aux.to_str(temp)+", "+id+"\n";
    code += "sw\t\t $t"+aux.to_str(start)+", 0($t"+aux.to_str(temp)+")\n";
    aux.freeReg(temp);
    code+="j\t\t "+label_for+"\n";

    code+="\n"+label_end_for+":\n\n";
    aux.freeReg(start);
    aux.freeReg(end);
    return 0;
}

gen(PrintList){
    code = "";
    for(const auto& val : vals){
        val->gen(vars);
        code += val->code;
    }
    return 0;
}

gen(PrintExpr)
{
    expr->gen(vars);

    code = expr->code;
    code+= "move\t\t $a0,$t"+aux.to_str(expr->place)+"\n";
    code+= "jal\t\t print_int\n";

    aux.freeReg(expr->place);
    return 0;
}

gen(PrintString)
{
    string_t var = aux.saveVar(vars,literal,2);
    code = "la\t\t $a0,"+var+"\n";
    code+= "jal\t\t print_str\n";

    return 0;
}

gen(IfStmt)
{
    cond->gen(vars);
    code = cond->code;
    std::cout<<"code:"+code+"\n";
    std::string label_if = aux.labelGenerator("if");
    std::string label_end_if = aux.labelGenerator("end_if");
    code+= "\n"+label_if+":\n\n";
    code+= "beq\t\t $t"+aux.to_str(cond->place)+", $zero, "+label_end_if +"\n";
    aux.freeReg(cond->place);

    true_blk->gen(vars);
    code+= true_blk->code;
    code+="\n"+label_end_if+":\n\n";

    if(false_blk != nullptr){
        false_blk->gen(vars);
        code+= false_blk->code;
    }

    return 0;
}

gen(ElseStmt)
{
    if(code_blk != nullptr){
        std::string label_else = aux.labelGenerator("else");
        code_blk->gen(vars);
        code = "\n"+label_else+":\n\n";
        code+= code_blk->code;
    }
    return 0;
}

gen(WhileStmt)
{
    return 0;
}
